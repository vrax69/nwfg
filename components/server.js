const express = require("express");
const multer = require("multer");
const fs = require("fs-extra");
const path = require("path");
const moment = require("moment");
const xlsx = require("xlsx");
const https = require("https");
const cors = require("cors");
const { Console } = require("console");

// Definir directorio base para todos los archivos
const baseDir = path.join(__dirname, "files");
const debugLogDir = path.join(baseDir, "logs");

// Asegurar que el directorio de logs existe
fs.ensureDirSync(debugLogDir);

// Configurar logger personalizado para informaci√≥n m√°s detallada
const logFile = fs.createWriteStream(path.join(debugLogDir, 'app-debug.log'), { flags: 'a' });
const logConsole = new Console({ stdout: logFile, stderr: logFile });

// Log de inicio de servidor
const startupLog = `\n===============================\nüìã SERVIDOR INICIADO: ${new Date().toISOString()}\n===============================\n`;
logConsole.log(startupLog);
console.log(startupLog);

// Cargar certificados SSL
const options = {
    key: fs.readFileSync("/etc/letsencrypt/live/nwfg.net/privkey.pem"),
    cert: fs.readFileSync("/etc/letsencrypt/live/nwfg.net/fullchain.pem")
};

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware para permitir JSON con l√≠mite aumentado para archivos grandes
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Middleware de logging para todas las peticiones
app.use((req, res, next) => {
    const timestamp = moment().format("YYYY-MM-DD HH:mm:ss");
    console.log(`[${timestamp}] üìå ${req.method} ${req.path}`);
    logConsole.log(`[${timestamp}] üìå ${req.method} ${req.path}`);
    next();
});

// Habilitar CORS con configuraci√≥n mejorada
app.use(cors({
    origin: ["https://www.nwfg.net", "https://nwfg.net", "http://localhost:3000"],
    methods: ["GET", "POST", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
    credentials: true
}));

// Configurar almacenamiento en memoria con Multer
const storage = multer.memoryStorage();
const upload = multer({ 
    storage: storage,
    limits: { fileSize: 10 * 1024 * 1024 } // L√≠mite de 10MB
});

// üìå Ruta para guardar las columnas seleccionadas en el paso 2
app.post("/save-selected-columns", async (req, res) => {
    try {
        const { supplier, selectedColumns } = req.body;
        
        if (!supplier || !selectedColumns || !Array.isArray(selectedColumns)) {
            console.error("‚ùå Error: Datos incompletos o inv√°lidos");
            return res.status(400).json({ 
                success: false, 
                error: "Se requiere proveedor y columnas seleccionadas en formato correcto" 
            });
        }
        
        // üìå Obtener la fecha actual
        const date = moment().format("YYYY-MM-DD");
        const time = moment().format("HH:mm:ss");
        
        // üìÇ Definir directorios y archivos necesarios
        const logDir = path.join(baseDir, "logs");
        const logFilePath = path.join(logDir, `${date}.log`);
        const tempDir = path.join(baseDir, "temp");
        const selectedColumnsFile = path.join(tempDir, `selected_columns_${supplier}.json`);
        
        // ‚úÖ Crear directorios si no existen
        await fs.ensureDir(logDir);
        await fs.ensureDir(tempDir);
        
        // üìå Guardar las columnas seleccionadas para usarlas en el paso 3
        await fs.writeJson(selectedColumnsFile, {
            supplier,
            columns: selectedColumns,
            timestamp: new Date().toISOString()
        }, { spaces: 2 });
        
        // üìå Actualizar el log con las columnas seleccionadas
        const logEntry = `
üîÑ [${time}] Paso 2 completado
üè¢ Proveedor: ${supplier}
‚úÖ Columnas seleccionadas: ${selectedColumns.length} (${selectedColumns.join(", ")})
`;
        await fs.appendFile(logFilePath, logEntry);
        
        console.log(`‚úÖ Columnas seleccionadas guardadas para ${supplier}: ${selectedColumns.length}`);
        logConsole.log(`‚úÖ Columnas seleccionadas guardadas para ${supplier}: ${selectedColumns.length}`);
        
        res.json({ 
            success: true, 
            message: `${selectedColumns.length} columnas seleccionadas guardadas correctamente` 
        });
        
    } catch (error) {
        console.error("‚ùå Error al guardar columnas seleccionadas:", error);
        logConsole.error("‚ùå Error al guardar columnas seleccionadas:", error);
        res.status(500).json({ success: false, error: `Error interno: ${error.message}` });
    }
});

// üìå Ruta para obtener las columnas seleccionadas para el paso 3
app.get("/get-selected-columns/:supplier", async (req, res) => {
    try {
        const supplier = req.params.supplier;
        if (!supplier) {
            return res.status(400).json({ success: false, error: "Se requiere especificar un proveedor" });
        }
        
        const tempDir = path.join(__dirname, "files", "temp");
        const selectedColumnsFile = path.join(tempDir, `selected_columns_${supplier}.json`);
        
        if (!await fs.pathExists(selectedColumnsFile)) {
            return res.status(404).json({ 
                success: false, 
                error: "No se encontraron columnas seleccionadas para este proveedor" 
            });
        }
        
        const data = await fs.readJson(selectedColumnsFile);
        
        console.log(`üìå Devolviendo columnas seleccionadas para ${supplier}: ${data.columns.length}`);
        
        res.json({ 
            success: true, 
            selectedColumns: data.columns, 
            timestamp: data.timestamp
        });
        
    } catch (error) {
        console.error("‚ùå Error al obtener columnas seleccionadas:", error);
        logConsole.error("‚ùå Error al obtener columnas seleccionadas:", error);
        res.status(500).json({ success: false, error: `Error interno: ${error.message}` });
    }
});

// üìå Ruta para subir archivos
app.post("/upload", upload.single("file"), async (req, res) => {
    try {
        const file = req.file;
        const supplier = req.body.supplier;
        // Recuperar y parsear selectedColumns si existen
        const selectedColumns = req.body.selectedColumns ? JSON.parse(req.body.selectedColumns) : [];

        console.log("üìå Columnas seleccionadas recibidas en el backend:", selectedColumns);
        logConsole.log("üìå Columnas seleccionadas recibidas en el backend:", selectedColumns);

        if (!file || !supplier) {
            console.error("‚ùå Error: Falta el archivo o el proveedor");
            return res.status(400).json({ success: false, error: "Falta el archivo o el proveedor (supplier)." });
        }

        // üìå Validar tipo de archivo
        const validFileTypes = ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.ms-excel"];
        if (!validFileTypes.includes(file.mimetype)) {
            console.error(`‚ùå Error: Tipo de archivo inv√°lido - ${file.mimetype}`);
            return res.status(400).json({ success: false, error: "Tipo de archivo inv√°lido. Solo se permiten archivos Excel (.xlsx o .xls)" });
        }

        // üìå Obtener la fecha actual
        const date = moment().format("YYYY-MM-DD");
        const time = moment().format("HH:mm:ss");

        // üìÇ Definir rutas para almacenamiento de archivos
        const supplierDir = path.join(baseDir, supplier);
        const dateDir = path.join(supplierDir, date);
        const filePath = path.join(dateDir, file.originalname);
        
        // üìÇ Definir rutas para logs (ahora dentro de files/logs)
        const logDir = path.join(baseDir, "logs");
        const logFilePath = path.join(logDir, `${date}.log`);

        // ‚úÖ Crear las carpetas necesarias si no existen
        await fs.ensureDir(dateDir);
        await fs.ensureDir(logDir);

        // üìå Guardar el archivo
        await fs.writeFile(filePath, file.buffer);

        // üìå Leer el archivo Excel para extraer las columnas
        let workbook, sheetName, worksheet, jsonData;
        try {
            workbook = xlsx.read(file.buffer, { type: "buffer" });
            sheetName = workbook.SheetNames[0];
            worksheet = workbook.Sheets[sheetName];
            jsonData = xlsx.utils.sheet_to_json(worksheet, { header: 1 });
        } catch (excelError) {
            console.error("‚ùå Error al leer el archivo Excel:", excelError);
            return res.status(400).json({ 
                success: false, 
                error: "Error al leer el archivo Excel. Verifica que el formato sea correcto." 
            });
        }

        // üìå Extraer nombres de columnas
        const columns = jsonData[0] || [];

        if (columns.length === 0) {
            console.error("‚ùå Error: No se encontraron columnas en el archivo");
            return res.status(400).json({ 
                success: false, 
                error: "No se encontraron columnas en el archivo. Verifica el formato del Excel." 
            });
        }

        // üìå Extraer muestras de datos para cada columna (hasta 5 filas)
        const samples = {};
        if (columns.length > 0 && jsonData.length > 1) {
            columns.forEach((col, colIndex) => {
                samples[col] = [];
                for (let i = 1; i < Math.min(jsonData.length, 6); i++) {
                    if (jsonData[i][colIndex] !== undefined) {
                        samples[col].push(jsonData[i][colIndex]);
                    }
                }
            });
        }

        // üìå Guardar log con detalles y columnas seleccionadas
        const logEntry = `
üóÇÔ∏è [${time}] 
üìÑ Archivo: ${file.originalname} | üè¢ Proveedor: ${supplier}
üìä Columnas totales: ${columns.length} (${columns.join(", ")})
‚úÖ Columnas seleccionadas: ${selectedColumns.length > 0 ? selectedColumns.join(", ") : "‚è≥ A√∫n no seleccionadas"}
`;
        
        await fs.appendFile(logFilePath, logEntry);

        console.log(`‚úÖ Archivo subido: ${file.originalname} - Columnas: ${columns.length}`);
        logConsole.log(`‚úÖ Archivo subido: ${file.originalname} - Columnas: ${columns.length}`);

        // üìå Responder con las columnas extra√≠das y muestras de datos
        res.json({ 
            success: true, 
            message: "Archivo subido y guardado correctamente.", 
            columns,
            samples,
            selectedColumns // Devolver tambi√©n las columnas seleccionadas para verificaci√≥n
        });
    } catch (error) {
        console.error("‚ùå Error al subir archivo:", error);
        logConsole.error("‚ùå Error al subir archivo:", error);
        res.status(500).json({ success: false, error: `Error interno del servidor: ${error.message}` });
    }
});

// üìå Ruta para obtener columnas del backend (necesaria para el frontend)
app.get("/columns", async (req, res) => {
    try {
        // Puedes reemplazar esto con una consulta a la base de datos real si lo necesitas
        const columns = [
            "Rate_ID", "SPL_Utility_Name", "Product_Name", "Rate", "ETF", 
            "MSF", "Term", "Company_DBA_Name", "Service_Type", "Last_Updated", "SPL"
        ];
        
        console.log("üìå Devolviendo columnas de base de datos:", columns.length);
        res.json({ success: true, columns });
    } catch (error) {
        console.error("‚ùå Error obteniendo columnas:", error);
        logConsole.error("‚ùå Error obteniendo columnas:", error);
        res.status(500).json({ success: false, error: "Error interno del servidor." });
    }
});

// üìå Ruta para mapear columnas y guardar datos
app.post("/map-columns", async (req, res) => {
    try {
        const { supplier, columnMapping, rows, selectedColumns, headers } = req.body;

        if (!supplier || !columnMapping || !rows || rows.length === 0) {
            console.error("‚ùå Error: Faltan datos necesarios para el mapeo");
            return res.status(400).json({ 
                success: false,
                message: "Faltan datos necesarios (proveedor, mapping o filas)"
            });
        }

        console.log("üìå Supplier recibido:", supplier);
        console.log("üìå Columnas seleccionadas en /map-columns:", selectedColumns?.length || 0);
        console.log("üìå Mapping de columnas recibido:", Object.keys(columnMapping).length);
        console.log(`üìå Filas recibidas: ${rows.length}`);

        logConsole.log("üìå Supplier recibido:", supplier);
        logConsole.log("üìå Columnas seleccionadas en /map-columns:", selectedColumns);
        logConsole.log("üìå Mapping de columnas recibido:", columnMapping);
        logConsole.log(`üìå Filas recibidas: ${rows.length}`);

        // üìå Obtener la fecha actual
        const date = moment().format("YYYY-MM-DD");
        const time = moment().format("HH:mm:ss");

        // üìÇ Definir directorio para logs
        const logDir = path.join(baseDir, "logs");
        const mappingLogPath = path.join(logDir, `${date}.log`);

        // ‚úÖ Crear directorio de logs si no existe
        await fs.ensureDir(logDir);

        // üìå Guardar detalles del mapping en el log
        const mappingLogEntry = `
üóÇÔ∏è [${time}] üìÑ Archivo: ${supplier}
üìä Columnas totales en el archivo: ${headers?.length || 0} (${headers ? headers.join(", ") : "N/A"})
‚úÖ Columnas seleccionadas por el usuario: ${selectedColumns?.length || 0} (${selectedColumns ? selectedColumns.join(", ") : "N/A"})
üîÑ Mapping aplicado: ${JSON.stringify(columnMapping, null, 2)}
üìä Filas procesadas: ${rows.length}
`;
        await fs.appendFile(mappingLogPath, mappingLogEntry);

        console.log(`‚úÖ Mapeo completado - ${rows.length} filas procesadas`);
        logConsole.log(`‚úÖ Mapeo completado - ${rows.length} filas procesadas`);

        res.json({
            success: true,
            message: `${rows.length} filas procesadas correctamente`
        });

    } catch (error) {
        console.error("‚ùå Error en /map-columns:", error);
        logConsole.error("‚ùå Error en /map-columns:", error);
        res.status(500).json({ 
            success: false,
            message: `Error interno del servidor: ${error.message}`
        });
    }
});

// üìå Ruta para verificar el estado del servidor
app.get("/health", (req, res) => {
    res.json({ 
        status: "OK", 
        timestamp: new Date().toISOString(),
        version: "1.0.0" 
    });
});

// üìå Manejador de errores
app.use((err, req, res, next) => {
    console.error("‚ùå Error no controlado:", err);
    logConsole.error("‚ùå Error no controlado:", err);
    res.status(500).json({ success: false, error: "Error interno del servidor" });
});

// üìå Crear servidor HTTPS
https.createServer(options, app).listen(PORT, "0.0.0.0", () => {
    const startupMessage = `üîê Servidor seguro corriendo en https://nwfg.net:${PORT} - ${new Date().toISOString()}`;
    console.log(startupMessage);
    logConsole.log(startupMessage);
});